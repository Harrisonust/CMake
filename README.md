# CMake notes

## Commands
`cmake -S [source_path] -B [build_path]`

## Folder structure
* `bin/` - a folder that contains the compiled .DLL file or (sometimes) a .lib or the executable application or .exe file — the “binary”
* `include/` - a folder that contains the publicly distributed .h (header files) for a library to be included in another application, required to use a library or DLL, normally put **pure .h files** in
* `lib/` - a folder that contains **statically linkable**, **precompiled code** and is part of a library, library-builders mostly code their libraries in this folder
* `doc/` - all those nifty **manuals** programmers hate to write, or generated ones from the output of a source documentation utility like Doxygen, or a README file, or the .man files for Linux “man” command, or an offline website so you would see .html files
* `build/` - a folder that is sometimes there for holding onto **build scripts**, half-built code, other stuff related to the compilation process, usually it's generated by a utility or the compiler. There are other names for this folder on each platform
* `src/` - this is where the source code is, **users edit this stuff most frequently** (probably), and it may have sub-folders
* `data/` - some applications come with “sample data” or “test data” that usually sits in here and is accessed by the application in the bin/ folder
* `examples/` - some libraries come with a set of applications that test out various “units” of the “system” and also demonstrate usage
* `contrib/` - this used to mean “user-contributed snippets” or source code given to the primary author or authors for use or to extend an open-source project [3](or even a closed source one), though the “contrib” idea hit its popularity peak a long time ago, in a time when not everyone had a source versioning control utility like git
<br />
reference: https://www.linkedin.com/pulse/what-general-c-project-structure-like-herbert-elwood-gilliland-iii


## Common CMake functions
### Project commands
* `cmake_minuim_required(VERSION [X.x])`<br />
Set the cmake minimun required version, compile will aborted for cmake lower than this specified version
* `set([var] [value])`<br />
Set `var` = `value`
* `project([project_name] [VERSION X.x])`<br />
CMAKE_PROJECT_NAME = `project_name`<br />
CMAKE_PROJECT_VERSION = `X.x`<br />
CMAKE_PROJECT_VERSION_MAJOR = `X`<br />
CMAKE_PROJECT_VERSION_MINOR = `x`<br />

### Compiling
* `add_executable([target] [src])`<br />
Compile `src` into an executable `target`

* `add_subdirectory([dir])`<br />
Told the Cmake system there is a subdirectory which contains antoher sub-CMakeList.txt file and that will handle the build process of that subdir.

* `add_library([target] [STATIC|SHARED|MODULE] [src])`<br />
It will build `src` into an `target` library 
    * `STATIC` - statically linking(linking at compile time)
    * `SHARED` - dynamically linking(linking at runtime)
    * `MODULE` - ??

* `target_include_directories([target] [PUBLIC|PRIVATE] [include_dir_path])`<br />
target_include_directories(...) is required to do the simple #include "whatever.h" without needing to include the folder path in your C++ files

* `target_link_libraries([target] [PUBLIC|PRIVATE] [lib])`<br />
target_link_libraries(...) is required to link the main.cpp's output to the library's output so they can call each other in the build

* `configure_file([input] [output])`<br />
Copies an `input` file to an `output` file and substitutes variable values referenced as @VAR@ or ${VAR} in the input file content.

* `install([TARGETS|DIRECTORIES|FILES] [target] [LIBRARY] DESTINATION [path])`<br />
Install `target` to ${CMAKE_INSTALL_PREFIX}/`path`
    * `LIBRARY` - install to ${CMAKE_INSTALL_PREFIX}/lib

* `find_package([package] [version] [REQUIRED])`<br />
Find 3rd party library

* `install()`<br />
TODO

### Scripting commands

* `OPTION(OPTION_NAME HELP_MESSAGE DEFAULT_VALUE)`<br />
建立使用者選項參數，在例子中會建立一個使用者參數，名為 DOWNLOAD_MNIST，預設為 ON。

* `message([MODE] "message to display")`<br />
message 可以看做是 CMake 的 print。MODE 必須填入 CMake 提供的常數選項，比較常用的包括了 none(未給定), STATUS, WARNING 和 FATAL_ERROR。模式的不同會決定輸出的目的地，若是 STATUS 則會輸出於 stdout，其他則會輸出於 stderr。

* `execute_process(COMMAND CMD_NAME [ARGUMENTS...] [ERROR_VARIABLE VARIABLE_NAME])`<br />
execute_process 會在子程序內執行所給定的程式名稱。CMD_NAME 是執行程式的名稱，在例子中為 python。在 CMD_NAME 後的 ARGUMENTS 是字串陣列，作為執行程式的引數。最後 VARIABLE_NAME 是當程式運行失敗時，將會設為 true 的變數。

## Common CMake variable
* `CMAKE_SOURCE_DIR` - The root source directory
* `CMAKE_CURRENT_SOURCE_DIR` - The current source directory if using sub-projects and directories.
* `PROJECT_SOURCE_DIR` - The source directory of the current CMake project.
* `CMAKE_BINARY_DIR` - The root binary/build directory. This is the directory where you ran the CMake command.
* `CMAKE_CURRENT_BINARY_DIR` - The build directory you are currently in.
* `PROJECT_BINARY_DIR` - The build directory for the current project.
* `CMAKE_INSTALL_PREFIX` - Prefix path when calling make install
* `CMAKE_CXX_STANDARD` - c++ standard

#### platform-related
* `UNIX` - for all UNIX-like OS's, including Apple OS X and CygWin
* `WIN32` - for Windows. Prior to 2.8.4 this included CygWin
* `APPLE` - for Apple systems. Note this does not imply the system is Mac OSX, only that APPLE is #defined in C/C++ header files.
* `MINGW` - is TRUE when using the MinGW compiler in Windows
* `MSYS` - is TRUE when using the MSYS developer environment in Windows
* `CYGWIN` - for Windows when using the CygWin version of CMake